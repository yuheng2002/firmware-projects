/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

// ====================================================================
// Section 1: Memory Map Base Addresses
// ====================================================================
#define PERIPH_BASE         0x40000000UL                    // Base address for all peripherals
#define AHB1PERIPH_BASE     (PERIPH_BASE + 0x00020000UL)    // AHB1 bus base (connects GPIO, RCC, etc.)

// Peripheral Base Addresses
#define GPIOA_BASE          (AHB1PERIPH_BASE + 0x0000UL)    // GPIO Port A Base
#define GPIOC_BASE          (AHB1PERIPH_BASE + 0x0800UL)    // GPIO Port C Base
#define RCC_BASE            (AHB1PERIPH_BASE + 0x3800UL)    // Reset and Clock Control Base

// ====================================================================
// Section 2: Register Definitions (Dereferenced Pointers)
// ====================================================================
// RCC Registers
#define RCC_AHB1ENR_OFFSET  0x30UL
#define RCC_AHB1ENR         (*(volatile uint32_t*)(RCC_BASE + RCC_AHB1ENR_OFFSET))

// GPIO Port A Registers
#define GPIOA_MODER         (*(volatile uint32_t*)(GPIOA_BASE + 0x00UL)) // Mode Register
#define GPIOA_ODR           (*(volatile uint32_t*)(GPIOA_BASE + 0x14UL)) // Output Data Register

// GPIO Port C Registers
#define GPIOC_MODER         (*(volatile uint32_t*)(GPIOC_BASE + 0x00UL)) // Mode Register
#define GPIOC_IDR           (*(volatile uint32_t*)(GPIOC_BASE + 0x10UL)) // Input Data Register

// ====================================================================
// Section 3: Bit Definitions & Configuration Values
// ====================================================================
// GPIO Pin Definitions (Bit Masks)
#define GPIO_PIN_5          (1UL << 5)    // Pin 5 mask (0x00000020)
#define GPIO_PIN_13         (1UL << 13)   // Pin 13 mask (0x00002000)

// Clock Enable Bits
#define GPIOA_CLK_ENABLE    (1UL << 0)    // Enable Clock for Port A
#define GPIOC_CLK_ENABLE    (1UL << 2)    // Enable Clock for Port C

// Mode Register Configurations
// To set a mode, we first clear the bits (MASK) then set the specific mode value
#define GPIOA_PIN5_MODER_MASK   ~(3UL << 10)  // Clear bits 10 and 11
#define GPIOA_PIN5_OUTPUT_MODE  (1UL << 10)   // Set bit 10 to 1 (Output Mode 01)

#define GPIOC_PIN13_MODER_MASK  ~(3UL << 26)  // Clear bits 26 and 27 (Input Mode 00)

int main(void)
{
    // ====================================================================
    // Step 1: Clock Configuration (Power Up)
    // ====================================================================
    // Purpose: Before using any peripheral (GPIO), we must enable its clock.
    // Reference: RM0390 Reference Manual - Memory Map & RCC Section.

    // Base Address of RCC (Reset and Clock Control): 0x4002 3800
    // Register: RCC_AHB1ENR (AHB1 Peripheral Clock Enable Register)
    // Offset: 0x30 -> Absolute Address: 0x4002 3830

    // Logic:
    // Bit 2 controls GPIOC (for the User Button)
    // Bit 0 controls GPIOA (for the LD2 LED)
    // Writing '1' enables the clock.
    RCC_AHB1ENR |= GPIOC_CLK_ENABLE; // Enable GPIOC
    RCC_AHB1ENR |= GPIOA_CLK_ENABLE; // Enable GPIOA

    // ====================================================================
    // Step 2: GPIO Mode Configuration (Input vs Output)
    // ====================================================================
    // Hardware Mapping:
    // - Blue USER Button -> Connected to PC13 (Port C, Pin 13)
    // - Green LED (LD2)  -> Connected to PA5  (Port A, Pin 5)

    // Register: GPIOx_MODER (Mode Register)
    // Offset: 0x00 for both ports.

    // --- Configure PA5 (LED) as Output ---
    // Base Address of GPIOA: 0x4002 0000
    // Target: Pin 5. Controlled by bits [11:10].
    // Desired Mode: General Purpose Output (Binary: 01)

    // 1. Clear bits 11 and 10 (Reset state) to avoid conflicts.
    GPIOA_MODER &= GPIOA_PIN5_MODER_MASK;
    // 2. Set bit 10 to '1' to select Output Mode (01).
    GPIOA_MODER |= GPIOA_PIN5_OUTPUT_MODE;

    // --- Configure PC13 (Button) as Input ---
    // Base Address of GPIOC: 0x4002 0800
    // Target: Pin 13. Controlled by bits [27:26].
    // Desired Mode: Input (Binary: 00)

    // 1. Clear bits 27 and 26. Since Input mode is '00', clearing them is enough.
    GPIOC_MODER &= GPIOC_PIN13_MODER_MASK;

    // ====================================================================
    // Step 3: Main Loop (Polling)
    // ====================================================================
    while (1){
        // Goal: Implement "Active Low" logic.
        // The schematic shows the button pulls the pin to Ground (0) when pressed.
        // Released = 1 (High/3.3V), Pressed = 0 (Low/GND).

        // Addresses:
        // - IDR (Input Data Register) Offset: 0x10. Used to READ button.
        // - ODR (Output Data Register) Offset: 0x14. Used to WRITE LED.

        // Logic Check:
        // 1. Read the 32-bit value from GPIOC_IDR.
        // 2. Shift right by 13 (>> 13) to bring the 13th bit to position 0.
        // 3. Bitwise AND with 1 (& 1) to mask/ignore all other bits.
        // 4. Check if the result is 0 (Pressed).

        if ((GPIOC_IDR & GPIO_PIN_13) == 0){
            // Case: Button IS Pressed (Input is Low/0)
            // Action: Turn LED ON (Set PA5 to High/1)
            GPIOA_ODR |= GPIO_PIN_5;
        }
        else{
            // Case: Button IS NOT Pressed (Input is High/1 - Default State)
            // Action: Turn LED OFF (Reset PA5 to Low/0)
            GPIOA_ODR &= ~(GPIO_PIN_5);
        }
    }
}
