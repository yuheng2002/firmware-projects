/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f446xx_gpio_driver.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/*
 * ==========================================
 * Project 2: Interrupt-Driven LED State Machine
 * ==========================================
 * FSM States:
 * 0: OFF
 * 1: SOLID ON
 * 2: BLINKING
 */
volatile uint8_t g_LedState = 0;

/*
 * Software Delay Function
 * Intentionally wasting CPU cycles to create a delay.
 */
void software_delay(uint32_t count){
    for(uint32_t i = 0; i < count; i++){
        // Empty loop
    }
}

int main(void)
{
    // ==========================================
    // 1. Initialize LED (PA5) - Output Mode
    // ==========================================
    GPIO_Handle_t GPIO_LED;

    GPIO_LED.pGPIOx = GPIOA;
    GPIO_LED.GPIO_PinConfig.GPIO_PinNumber = 5;
    GPIO_LED.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_OUT;
    GPIO_LED.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;
    GPIO_LED.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
    GPIO_LED.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_PP;
    // Note: Alternate Function Mode is not applicable here.

    // Enable Clock for Port A
    GPIO_PeriClockControl(GPIOA, ENABLE);
    GPIO_Init(&GPIO_LED);

    // ==========================================
    // 2. Initialize User Button (PC13) - Interrupt Mode
    // ==========================================
    GPIO_Handle_t GPIO_USER_BUTTON;

    GPIO_USER_BUTTON.pGPIOx = GPIOC;
    GPIO_USER_BUTTON.GPIO_PinConfig.GPIO_PinNumber = 13;
    GPIO_USER_BUTTON.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_IT_FT; // Falling Edge Trigger
    GPIO_USER_BUTTON.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_VERY_HIGH;
    GPIO_USER_BUTTON.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;

    // Enable Clock for Port C
    GPIO_PeriClockControl(GPIOC, ENABLE);

    // Initialize User Button (This handles SYSCFG, EXTI, and NVIC configurations automatically)
    GPIO_Init(&GPIO_USER_BUTTON);

    // ==========================================
    // 3. Main Loop (Application Logic)
    // ==========================================
    while (1){
        // Finite State Machine (FSM) -> Controls LED behavior based on g_LedState
        switch(g_LedState){
            case 0: // OFF
                GPIO_WriteToOutputPin(GPIOA, 5, 0);
                break;
            case 1: // SOLID ON
                GPIO_WriteToOutputPin(GPIOA, 5, 1);
                break;
            case 2: // BLINK
				/*
				 * [How Blinking Works]
				 * Since we are inside an infinite while(1) loop, as long as g_LedState stays 2,
				 * the CPU will repeatedly enter this case.
				 *
				 * 1. Toggle: Uses XOR operation (^) to flip the pin state.
				 * - First pass: 0 (OFF) ^ 1 = 1 (ON)
				 * - Second pass: 1 (ON) ^ 1 = 0 (OFF)
				 *
				 * 2. Delay: Holds the current state (ON or OFF) for the duration of the delay.
				 * - software_delay(500000) â‰ˆ 125ms interval.
				 *
				 * The combined result is: ON -> Wait 125ms -> Loop back -> OFF -> Wait 125ms -> Loop back...
				 */
				GPIO_ToggleOutputPin(GPIOA, 5);
				software_delay(500000);
				break;
        }
    }
}

/*
 * ==========================================
 * Interrupt Service Routine (ISR) for EXTI Lines 10-15
 * ==========================================
 * This function handles the Hardware Interrupt triggered by PC13 (Falling Edge).
 *
 * KEY CONCEPT:
 * Unlike standard C functions, this is NOT called by main().
 * It is invoked directly by the Hardware (NVIC) via the Vector Table
 * when the specific interrupt event occurs.
 */
void EXTI15_10_IRQHandler(void)
{
    /*
     * Check Pending Register (EXTI -> PR)
     * We need to confirm that the interrupt was triggered by Line 13 (PC13).
     *
     * EXTI->PR & (1 << 13) evaluates to true (non-zero) if the 13th bit is set.
     */
    if(EXTI->PR & (1 << 13))
    {
        /*
         * [Software Debouncing]
         * A delay of ~50ms to ignore mechanical noise from the switch.
         *
         * OBSERVATION: On the NUCLEO-F446RE board, I tested without this delay
         * and it worked perfectly. This is likely due to the hardware RC Low-pass
         * filter (Capacitor + Resistor) built into the User Button circuit.
         * Keeping the logic here for robustness on other hardware.
         */
        software_delay(50000);

        // Update FSM State: 0 -> 1 -> 2 -> 0 ...
        g_LedState++;
        if(g_LedState > 2) {
            g_LedState = 0;
        }

        /*
         * CRITICAL STEP: Clear the Pending Bit
         * According to the Reference Manual, this bit is cleared by writing '1' to it.
         * If we don't clear it, the CPU will think the interrupt is still pending
         * and will get stuck in an infinite loop re-entering this function.
         */
        EXTI->PR |= (1 << 13);
    }
}
