/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f446xx.h"
#include "stm32f446xx_gpio_driver.h"
#include "stm32f446xx_timer_driver.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

// Project 2: PWM Breathing LED
// We will use TIM2 Channel 1 (connected to PA5)

void software_delay(uint32_t count){
    for(uint32_t i = 0; i < count; i++);
}

int main(void)
{
	/*
	 * ==========================================
	 * PA5 Alternate Function Configuration
	 * ==========================================
	 * Project Goal: Adjust the brightness of LED2 using PWM (Pulse Width Modulation).
	 *
	 * Why PWM?
	 * In modern embedded systems, PWM is preferred over analog methods (like variable resistors)
	 * because it is energy-efficient and allows digital control of power delivery.
	 * Directly changing circuit resistance (Ohm's Law) is impractical via software.
	 *
	 * Pin Mapping:
	 * LED2 is connected to GPIO Port A, Pin 5 (PA5).
	 * By default, PA5 is a general purpose I/O. We must switch it to "Alternate Function Mode"
	 * to hand over control from the CPU to an internal peripheral (Timer).
	 *
	 * Timer Selection (Refer to Datasheet Table 11. Alternate Function, on page 57):
	 * PA5 can be mapped to:
	 * 1. TIM2_CH1 (AF1) -> General Purpose Timer.
	 * 2. TIM8_CH1N (AF3) -> Advanced Control Timer (intended for motor control).
	 *
	 * Decision:
	 * We choose TIM2 (AF1) because it is a standard General Purpose Timer.
	 * TIM8 requires complex configuration (BDTR - Break and Dead-time Register)
	 * which is unnecessary for a simple LED breathing effect.
	 *
	 * Configuration:
	 * Set PA5 Alternate Function Register (AFRL) to AF1 (0001).
	 */

    // ==========================================
    // 1. Initialize LED (PA5) - Alternate Function Mode
    // ==========================================
	// Before the Timer can output signals, the pin (PA5) needs to be mapped to it.
    GPIO_Handle_t GPIO_LED;

    GPIO_LED.pGPIOx = GPIOA;
    GPIO_LED.GPIO_PinConfig.GPIO_PinNumber = 5;
    GPIO_LED.GPIO_PinConfig.GPIO_PinMode = GPIO_MODE_ALTN; // Switch from GPIO to Alternate Function
    GPIO_LED.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPEED_HIGH;
    GPIO_LED.GPIO_PinConfig.GPIO_PinPuPdControl = GPIO_NO_PUPD;
    GPIO_LED.GPIO_PinConfig.GPIO_PinAltFunMode = GPIO_AF_1; // defined in gpio_driver.h
    														// AF1 corresponds to TIM2_CH1 (Check Datasheet Table 11)
    GPIO_PeriClockControl(GPIOA, ENABLE); // 1. Enable Port A Clock
    GPIO_Init(&GPIO_LED); // 2. Configure PA5 registers

    // ==========================================
    // Enable TIM2 (Essential! Otherwise registers are locked)
    // ==========================================
    TIM2_PCLK_EN(); // defined in timer_driver.h

    TIM_Handle_t Timer2Handle;
    Timer2Handle.pTIMx = TIM2; // TIM2 is defined in stm32f446xx.h using its base address
    						   // as a TIM_RegDef_t type pointer
    /*
	 * ==========================================
	 * Timer Configuration Strategy
	 * ==========================================
	 *
	 * [1. Design Goal: Why 1kHz?]
	 * The goal is to drive the LED with a PWM signal to control brightness.
	 * Due to the "Persistence of Vision" effect, the human eye cannot detect flickering
	 * if the frequency is high enough.
	 * - Standard movies: 24Hz
	 * - Gaming monitors: 144Hz - 240Hz (Smoother is better)
	 * - Target for this LED: 1kHz (1000Hz).
	 * This ensures a completely stable light output to the human eye with no visible flickering.
	 *
	 * [2. Time Base Calculation: How to get 1kHz?]
	 * The STM32 Timer acts like a gearbox. We need to reduce the high-speed CPU clock
	 * down to our target tick rate.
	 *
	 * Formula: PWM_Freq = System_Clk / ((PSC + 1) * (ARR + 1))
	 *
	 * - Step A: System Clock (Input)
	 * Source: HSI (Internal RC Oscillator) = 16 MHz
	 *
	 * - Step B: Prescaler (PSC) -> "The Gearbox"
	 * We want to slow down the 16MHz clock to a simple 1MHz counting speed (1 us/tick).
	 * Calculation: 16 MHz / 1 MHz = 16
	 * Register Setting: PSC = 15 (because divider = PSC + 1)
	 *
	 * - Step C: Auto-Reload Register (ARR) -> "The Cycle Length"
	 * Now we have a 1MHz clock (1 tick = 1 us).
	 * To get a 1kHz PWM frequency (Period = 1ms = 1000us), we need to count 1000 ticks.
	 * Register Setting: ARR = 999 (because counts are 0 to 999)
	 *
	 * Result: The Timer will reset every 1ms, creating a perfect 1kHz carrier frequency.
	 */
	Timer2Handle.TIM_Config.Prescaler = 15;
	Timer2Handle.TIM_Config.Period = 999; // ARR

    // Must pass the ADDRESS (&) of the handle!
    // Because the function expects a pointer: void TIM_PWM_Init(TIM_Handle_t *pTIMHandle)
    TIM_PWM_Init(&Timer2Handle); // Initialize TIM2

    // ==========================================
    // Part 3: The Breathing Loop (Duty Cycle Control)
    // ==========================================
    while (1){
    	/*
		 * Understanding Capture/Compare (CCR):
		 * CNT (Counter) is constantly counting: 0, 1, 2 ... 999 -> 0 ...
		 * CCR1 determines the "Threshold".
		 * * Logic (PWM Mode 1):
		 * - If CNT < CCR1 -> Output HIGH (LED ON)
		 * - If CNT >= CCR1 -> Output LOW (LED OFF)
		 * * Example:
		 * If CCR1 = 100 (and ARR=999):
		 * LED is ON for counts 0-99 (10% of the time) -> Dim
		 * If CCR1 = 900:
		 * LED is ON for counts 0-899 (90% of the time) -> Bright
		 */

    	// Phase 1: Fade In (0% -> 100%)
    	for (int i = 0; i <= 999; i++){
    		TIM_SetCompare1(TIM2, i); // Modify CCR1 register
    		software_delay(500); // // Wait a bit so eyes can see the change
    	}

    	// Phase 2: Fade Out (100% -> 0%)
    	for (int i = 999; i >= 0; i--){
    		TIM_SetCompare1(TIM2, i);
    		software_delay(500);
    	}
    }
}
